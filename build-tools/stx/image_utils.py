# Copyright (c) 2024 Wind River Systems, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
import os
import subprocess
import tempfile
import utils
import xml.etree.ElementTree as ET
import yaml

DEFAULT_ISO_NAME = 'starlingx-intel-x86-64-cd'
PATH_DEPLOY = '/localdisk/deploy'

logger = logging.getLogger('image_utils')
utils.set_logger(logger)

class ImageUtils():
    def __init__(self, yaml_file):
        self.iso_path = self.get_iso_fullpath(yaml_file)

    def get_version_metadata(self, mount_point):
        """
        Get the version from the metadata upgrades file.

        :param mount_point: Path where the iso is mounted
        :return: Version value
        """
        try:
            tree = ET.parse(os.path.join(mount_point,"upgrades/metadata.xml"))
            tree_root = tree.getroot()
            version = tree_root.find("version")
            return version.text
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)

    def get_iso_fullpath(self,yaml_file):
        """
        Get the full path for the iso file using the lat.yaml configuration
        file.

        :param yaml_file: Path to the yaml file
        :return: Full path to the ISO
        """
        try:
            with open(yaml_file) as f:
                lat_yaml = yaml.safe_load(f)
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)

        iso_name = DEFAULT_ISO_NAME

        if lat_yaml['name'] and lat_yaml['machine']:
            iso_name = lat_yaml['name'] + '-' + lat_yaml['machine'] + '-cd'

        fullpath = f'{PATH_DEPLOY}/{iso_name}.iso'

        if os.path.islink(fullpath):
            return os.path.realpath(fullpath)
        else:
            return fullpath

    def get_pkgs_from_yaml(self, path_to_file):
        """
        Get the debs filenames from packages.yaml generated by LAT

        :param path_to_file: Full path name to package.yaml
        :return: List of packages name
        """
        logger.info("Getting packages from: %s" % path_to_file)
        try:
            with open(path_to_file) as f:
                yaml_list = yaml.safe_load(f)
                packages = []
                for pkg in yaml_list:
                    packages.append(yaml_list[pkg]['filename'])
                return packages
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)

    def add_pkgs_metadata(self, packages, metadata_path):
        """
        Add packages (eg. <deb>name</deb>) to packages tags
        on the *-metadata.xml

        :param packages: List with packages names
        :param metadata_path: Full path to the metadata file
        """
        logger.info("Adding packages to: %s" % metadata_path)
        try:
            cmd = ["sudo","chmod", "a+rw", metadata_path]
            subprocess.check_call(cmd, shell=False)

            xml_parse = ET.parse(metadata_path)
            xml_top_element = xml_parse.getroot()
            pkg_tag = ET.SubElement(xml_top_element, "packages")
            for pkg in packages:
                ET.SubElement(pkg_tag,'deb').text = str(pkg)

            # Save XML
            xml_parse.write(metadata_path)
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)

    def get_label_from_isolinux_cfg(self, path_to_file):
        """
        Get the iso label from the isolinux.cfg.
        This file is not usually formatted so we need to find the exact line
        where the value is.

        :param path_to_file: Full path name to isolinux.cfg file
        :return: The instiso value
        """
        logger.info("Getting instiso label from: %s" % path_to_file)
        try:
            with open(path_to_file, 'r') as file:
                iso_label = None
                split_line = []
                for line in file:
                    if 'instiso=' in line:
                        split_line = line.split()
                        break

                for item in split_line:
                    if 'instiso=' in item:
                        split_item = item.split('=')
                        iso_label = split_item[1]
                        break

                return iso_label
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)

    def mount_iso(self, path_to_mount):
        """
        Try to mount the ISO in a directory

        :param path_to_mount: Path to directory where iso will be mounted
        """
        logger.info("Mounting ISO on: %s" % path_to_mount)
        if not os.path.isfile(self.iso_path):
            raise Exception("ISO not found: %s" % self.iso_path)

        if not os.path.exists(path_to_mount):
            raise Exception("Mount path not found: %s" % path_to_mount)

        # We try to mount the iso in the folder
        try:
            cmd = ["sudo", "mount", "-o", "loop", self.iso_path, path_to_mount]
            subprocess.check_call(cmd, shell=False)
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)
        else:
            logger.info("ISO sucessfully mounted")

    def unpack_iso(self, mount_point, unpack_directory):
        """
        Try to move everything that was inside of the mounted dir
        to directory where we can modifiy files.

        :param mount_point: Path to directory where ISO is mounted
        :param unpack_directory: Path to directory where files will be copied
        """
        logger.info("Unpacking ISO on: %s" % unpack_directory)
        if not os.path.exists(mount_point):
            raise Exception("Mount point directory not found: %s" % mount_point)

        if not os.path.exists(unpack_directory):
            raise Exception("Unpack directory not found: %s" % unpack_directory)

        try:
            cmd = ["sudo", "rsync", "-a", f'{mount_point}/', unpack_directory]
            subprocess.check_call(cmd, shell=False)
        except Exception as e:
            logger.error(str(e))
            raise Exception(e)
        else:
            logger.info("Files sucessfuly moved to unpack directory")

    def pack_iso(self, pack_directory, iso_label, overwrite=False):
        """
        Create a new ISO or overwrite existing ISO

        :param pack_directory: Path to where the files are present
        :param iso_label: Value to be usad as volume ID
        :param overwrite: If we should overwrite the ISO file or create new one
        :return: Returns the path of the new ISO
        """
        logger.info("Packing new ISO")
        iso_temporary_folder = tempfile.mkdtemp(prefix='iso_')
        new_iso_path=os.path.join(iso_temporary_folder,'new.iso')
        try:
            # Here we use mkisofs command to create the iso, the parameters
            # are so the iso is created with eltorito header and on ISO 9660 format
            cmd = ["sudo", "mkisofs", "-o", new_iso_path, "-A", iso_label, "-V", iso_label,
                "-quiet", "-U", "-J", "-joliet-long", "-r", "-iso-level", "2",
                "-b", "isolinux/isolinux.bin", "-c", "isolinux/boot.cat", "-no-emul-boot",
                "-boot-load-size","4","-boot-info-table","-eltorito-alt-boot","-e","efi.img",
                "-no-emul-boot", pack_directory
            ]
            subprocess.check_call(cmd, shell=False)

            # Making the iso EFI bootable
            cmd = ["sudo", "isohybrid", "--uefi", new_iso_path]
            subprocess.check_call(cmd, shell=False)

            # Implant new checksum, required for ISO9660 image
            cmd = ["sudo", "implantisomd5", new_iso_path]
            subprocess.check_call(cmd, shell=False)

            # if ovewrite equals true, we overwrite the original ISO from the yaml file
            # and return it's value
            if overwrite:
                subprocess.check_call(["sudo", "cp", "-f", new_iso_path, self.iso_path], shell=False)
                subprocess.check_call(["sudo", "rm", "-rf", iso_temporary_folder], shell=False)
                logger.info("ISO overwritten sucessfully on: %s" % self.iso_path)
                return self.iso_path
            else:
                logger.info("ISO sucessfully created on: %s" % new_iso_path)
                return new_iso_path
        except Exception as e:
            subprocess.check_call(["sudo", "rm", "-rf", iso_temporary_folder], shell=False)
            logger.error(str(e))
            raise Exception(e)

    def umount_iso(self, mount_point):
        """
        Try to umount ISO from directory

        :param mount_pount: Path where the mount is on
        """
        logger.info("Unmounting: %s" % mount_point)
        try:
            cmd = ["sudo", "umount", "-l", mount_point]
            subprocess.check_call(cmd, shell=False)
        except Exception as e:
            logger.error("Unmounting failed")
            logger.error(str(e))
        else:
            logger.info("Unmounted sucessfully")
